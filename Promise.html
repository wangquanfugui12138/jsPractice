<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Promise</title>
</head>

<body>
  <script>
    function Promise(fn) {
      var state = 'pending',
        value = null,
        callbacks = []

      this.then = function (onFulfilled, onRejected) {
        return new Promise(function (resolve, reject) {
          handle({
            onFulfilled: onFulfilled || null,
            onRejected: onRejected || null,
            resolve: resolve,
            reject: reject
          })
        })
      }

      function handle(callback) {
        if (state === 'pending') {
          callbacks.push(callback)
          return
        }

        var cb = state === 'fulfilled' ? callback.onFulfilled : callback.onRejected,
          ret
        if (cb === null) {
          cb = state === 'fulfilled' ? callback.resolve : callback.reject
          cb(value)
          return
        }
        ret = cb(value)
        callback.resolve(ret)
      }

      function resolve(newValue) {
        if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
          var then = newValue.then
          if (typeof then === 'function') {
            then.call(newValue, resolve, reject)
            return
          }
        }
        state = 'fulfilled'
        value = newValue
        execute()
      }

      function reject(reason) {
        state = 'rejected'
        value = reason
        execute()
      }

      function execute() {
        setTimeout(function () {
          callbacks.forEach(function (callback) {
            handle(callback)
          })
        }, 0)
      }

      fn(resolve, reject)
    }
    const p = function () {
      return new Promise((res, rej) => {
        setTimeout(() => {
          document.write('<div style="color:red">Promise succeed!</div>')
          res('Promise succeed!')
        }, 2000)
      })
    }
    function test() {
      const r = p().then(r => console.log(r))

    }
    test()
    console.log('hahahhahahahah')
  </script>
  <script>
    class Promise {
      constructor(fn) {
        this.state = 'pending'
        this.value = undefined
        this.reason = undefined
        // 成功方法数组
        this.onResolvedCallbacks = []
        // 失败方法数组
        this.onRejectedCallbacks = []
        let resolve = value => {
          if (value instanceof Promise) {
            return value.then(resolve, reject);
          }
          // 实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。
          setTimeout(() => {
            if (this.state === 'pending') {
              this.state = 'fulfilled'
              this.value = value
              this.onResolvedCallbacks.forEach(cb => cb(this.value))
            }
          })

        }
        let reject = reason => {
          setTimeout(() => {
            if (this.state === 'pending') {
              this.state = 'rejected'
              this.reason = reason
              this.onRejectedCallbacks.forEach(cb => cb(this.reason))
            }
          })

        }
        try {
          fn(resolve, reject)
        } catch (err) {
          reject(err)
        }
      }
      then(onFulfilled, onRejected) {
        if (this.state === 'fulfilled') {
          onFulfilled(this.value)
        }
        if (this.state === 'rejected') {
          onRejected(this.reason)
        }
        if (this.state === 'pending') {
          this.onResolvedCallbacks.push(() => {
            onFulfilled(this.value)
          })
          this.onRejectedCallbacks.push(() => {
            onRejected(this.reason)
          })
        }
      }
    }

    const p = function () {
      return new Promise((res, rej) => {
        setTimeout(() => {
          document.body.innerHTML = '<div style="color:red">Promise succeed!</div>'
          res('Promise succeed!')
        }, 2000)
      })
    }
    p().then(val => console.log(val))
  </script>
  <script>
    class Promise1 {
      constructor(fn) {
        this.state = 'pending'
        this.value = ''
        this.reason = ''

        this.resolvedCb = []
        this.rejectedCb = []

        function resolve(value) {
          if (this.state !== 'pending') return
          this.state = 'fulfilled'
          this.value = value
          this.resolvedCb.forEach(cb => cb())
        }
        function reject(reason) {
          if (this.state !== 'pending') return
          this.state = 'rejected'
          this.reason = reason
          this.rejectedCb.forEach(cb => cb())
        }
        try {
          fn(resolve, reject)
        } catch (err) {
          reject(err)
        }
      }
      then(resCb, rejCb) {
        if (this.state === 'fulfilled') {
          resCb(this.value)
        } else if (this.state === 'rejected') {
          rejCb(this.reason)
        } else if (this.state === 'pending') {
          this.resolvedCb.push(resCb)
          this.rejectedCb.push(rejCb)
        }
      }
    }
  </script>
</body>

</html>